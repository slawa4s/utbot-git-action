/*
 * This file is automatically generated by UnitTestBot. For further information see https://github.com/UnitTestBot/UTBotCpp
 * Copyright (c) Huawei Technologies Co., Ltd. 2012-2021. All rights reserved.
 */

namespace UTBot {
#define typeid typeid_
#define throw throw_
#define true true_
#define thread_local thread_local_
#define template template_
#define static_cast static_cast_
#define requires requires_
#define public public_
#define protected protected_
#define reflexpr reflexpr_
#define operator operator_
#define noexcept noexcept_
#define new new_
#define namespace namespace_
#define mutable mutable_
#define try try_
#define private private_
#define friend friend_
#define false false_
#define virtual virtual_
#define nullptr nullptr_
#define export export_
#define this this_
#define explicit explicit_
#define typename typename_
#define delete delete_
#define decltype decltype_
#define co_yield co_yield_
#define co_return co_return_
#define co_await co_await_
#define const_cast const_cast_
#define constinit constinit_
#define consteval consteval_
#define class class_
#define synchronized synchronized_
#define char32_t char32_t_
#define constexpr constexpr_
#define char8_t char8_t_
#define catch catch_
#define using using_
#define char16_t char16_t_
#define atomic_noexcept atomic_noexcept_
#define concept concept_
#define atomic_commit atomic_commit_
#define static_assert static_assert_
#define atomic_cancel atomic_cancel_
#define dynamic_cast dynamic_cast_
#define asm asm_
#define reinterpret_cast reinterpret_cast_
#define alignof alignof_
#define alignas alignas_
#define _Alignas(x)
#define _Atomic(x) x
#define _Bool bool
#define _Noreturn
#define _Thread_local thread_local

typedef void (*handler_type)(int);


extern "C" int (*counter_lib_globals_c);
int (&counter) = (*counter_lib_globals_c);
extern "C" int increment_lib_globals_c();
static int increment() {
return increment_lib_globals_c();
}
extern "C" void *(*memory_lib_globals_c);
void *(&memory) = (*memory_lib_globals_c);
extern "C" void **(*memory2_lib_globals_c);
void **(&memory2) = (*memory2_lib_globals_c);
extern "C" bool (*static_global_lib_globals_c);
bool (&static_global) = (*static_global_lib_globals_c);
extern "C" const bool (*const_global_lib_globals_c);
const bool (&const_global) = (*const_global_lib_globals_c);
extern "C" bool (*non_static_global_lib_globals_c);
bool (&non_static_global) = (*non_static_global_lib_globals_c);
extern "C" int use_globals_lib_globals_c(int default_value);
static int use_globals(int default_value) {
return use_globals_lib_globals_c(default_value);
}
extern "C" const int (*global_const_array_lib_globals_c)[3];
const int (&global_const_array)[3] = (*global_const_array_lib_globals_c);
extern "C" int (*global_array_lib_globals_c)[3];
int (&global_array)[3] = (*global_array_lib_globals_c);
extern "C" int use_global_array_lib_globals_c(int x);
static int use_global_array(int x) {
return use_global_array_lib_globals_c(x);
}
extern "C" char *(*global_mutable_string_lib_globals_c);
char *(&global_mutable_string) = (*global_mutable_string_lib_globals_c);
extern "C" const char *(*global_const_string_lib_globals_c);
const char *(&global_const_string) = (*global_const_string_lib_globals_c);
extern "C" char use_global_strings_lib_globals_c();
static char use_global_strings() {
return use_global_strings_lib_globals_c();
}
extern "C" int *(*global_mutable_int_array_lib_globals_c);
int *(&global_mutable_int_array) = (*global_mutable_int_array_lib_globals_c);
extern "C" const int *(*global_const_int_array_lib_globals_c);
const int *(&global_const_int_array) = (*global_const_int_array_lib_globals_c);
extern "C" int use_global_arrays_lib_globals_c();
static int use_global_arrays() {
return use_global_arrays_lib_globals_c();
}
extern "C" handler_type (*handler_lib_globals_c);
handler_type (&handler) = (*handler_lib_globals_c);
extern "C" void use_global_handler_lib_globals_c(int status);
static void use_global_handler(int status) {
return use_global_handler_lib_globals_c(status);
}

}
#undef typeid
#undef throw
#undef true
#undef thread_local
#undef template
#undef static_cast
#undef requires
#undef public
#undef protected
#undef reflexpr
#undef operator
#undef noexcept
#undef new
#undef namespace
#undef mutable
#undef try
#undef private
#undef friend
#undef false
#undef virtual
#undef nullptr
#undef export
#undef this
#undef explicit
#undef typename
#undef delete
#undef decltype
#undef co_yield
#undef co_return
#undef co_await
#undef const_cast
#undef constinit
#undef consteval
#undef class
#undef synchronized
#undef char32_t
#undef constexpr
#undef char8_t
#undef catch
#undef using
#undef char16_t
#undef atomic_noexcept
#undef concept
#undef atomic_commit
#undef static_assert
#undef atomic_cancel
#undef dynamic_cast
#undef asm
#undef reinterpret_cast
#undef alignof
#undef alignas
#include <cstring>

#include <unistd.h>


void utbot_redirect_stdin(const char* buf, int &res) {
    int fds[2];
    if (pipe(fds) == -1) {
        res = -1;
        return;
    }
    close(STDIN_FILENO);
    dup2(fds[0], STDIN_FILENO);
    write(fds[1], buf, 64);
    close(fds[1]);
}

template<typename T, size_t N>
T from_bytes(const char (&bytes)[N]) {
    T result;
    std::memcpy(&result, bytes, sizeof(result));
    return result;
}
