/*
 * This file is automatically generated by UnitTestBot. For further information seehttps://unittestbot.org
 */

#include "types_dot_c_test.h"

#include "gtest/gtest.h"
namespace UTBot {
static const float utbot_abs_error = 1e-6;


#pragma region regression
TEST(regression, a_or_b_test_1)
{
    char actual = a_or_b('p', 'b');
    EXPECT_EQ('b', actual);
}

TEST(regression, a_or_b_test_2)
{
    char actual = a_or_b('a', 'b');
    EXPECT_EQ('a', actual);
}

TEST(regression, a_or_b_test_3)
{
    char actual = a_or_b('p', 'j');
    EXPECT_EQ('p', actual);
}

TEST(regression, a_or_b_test_4)
{
    char actual = a_or_b('b', 'n');
    EXPECT_EQ('n', actual);
}

TEST(regression, max_long_test_1)
{
    long long actual = max_long(0LL, -1LL);
    EXPECT_EQ(0LL, actual);
}

TEST(regression, max_long_test_2)
{
    long long actual = max_long(0LL, 0LL);
    EXPECT_EQ(0LL, actual);
}

TEST(regression, min_short_test_1)
{
    short actual = min_short(-2, 0);
    EXPECT_EQ(-2, actual);
}

TEST(regression, min_short_test_2)
{
    short actual = min_short(0, 0);
    EXPECT_EQ(0, actual);
}

TEST(regression, min_divided_by_2_test_1)
{
    short actual = min_divided_by_2(-2, 0);
    EXPECT_EQ(-1, actual);
}

TEST(regression, min_divided_by_2_test_2)
{
    short actual = min_divided_by_2(0, 0);
    EXPECT_EQ(0, actual);
}

TEST(regression, some_func_test_1)
{
    signed char actual = some_func('a', 122);
    EXPECT_EQ('0', actual);
}

TEST(regression, some_func_test_2)
{
    signed char actual = some_func('{', 122);
    EXPECT_EQ('{', actual);
}

TEST(regression, some_func_test_3)
{
    signed char actual = some_func('a', 120);
    EXPECT_EQ('x', actual);
}

TEST(regression, fun_that_accept_bools_test_1)
{
    int actual = fun_that_accept_bools(true, false);
    EXPECT_EQ(2, actual);
}

TEST(regression, fun_that_accept_bools_test_2)
{
    int actual = fun_that_accept_bools(true, true);
    EXPECT_EQ(1, actual);
}

TEST(regression, fun_that_accept_bools_test_3)
{
    int actual = fun_that_accept_bools(false, true);
    EXPECT_EQ(3, actual);
}

TEST(regression, fun_that_accept_bools_test_4)
{
    int actual = fun_that_accept_bools(false, false);
    EXPECT_EQ(4, actual);
}

TEST(regression, is_positive_test_1)
{
    _Bool actual = is_positive(1);
    EXPECT_EQ(true, actual);
}

TEST(regression, is_positive_test_2)
{
    _Bool actual = is_positive(0);
    EXPECT_EQ(false, actual);
}

TEST(regression, supported_parameter_1_test_1)
{
    int actual = supported_parameter_1({
        .a = 0,
        .c = NULL});
    EXPECT_EQ(1, actual);
}

TEST(regression, supported_parameter_2_test_1)
{
    int actual = supported_parameter_2({
        .st = NULL});
    EXPECT_EQ(2, actual);
}

TEST(regression, pointer_to_pointer_test_1)
{
    int _a[2][2] = {{1, 0}, {0, 0}};
    int ** a = (int **) calloc(3, sizeof(int *));
    for (int it_280_0 = 0; it_280_0 < 2; it_280_0 ++) {
        a[it_280_0] = _a[it_280_0];
    }
    a[2] = NULL;
    pointer_to_pointer(a);
    int expected_a[2][2] = {{1, 0}, {0, 2}};
    for (int it_281_0 = 0; it_281_0 < 2; it_281_0 ++) {
        for (int it_281_1 = 0; it_281_1 < 2; it_281_1 ++) {
            EXPECT_EQ(expected_a[it_281_0][it_281_1], _a[it_281_0][it_281_1]);
        }
    }
}

TEST(regression, pointer_to_pointer_test_2)
{
    int _a[2][2] = {{0, 0}, {0, 0}};
    int ** a = (int **) calloc(3, sizeof(int *));
    for (int it_282_0 = 0; it_282_0 < 2; it_282_0 ++) {
        a[it_282_0] = _a[it_282_0];
    }
    a[2] = NULL;
    pointer_to_pointer(a);
    int expected_a[2][2] = {{0, 0}, {0, 0}};
    for (int it_283_0 = 0; it_283_0 < 2; it_283_0 ++) {
        for (int it_283_1 = 0; it_283_1 < 2; it_283_1 ++) {
            EXPECT_EQ(expected_a[it_283_0][it_283_1], _a[it_283_0][it_283_1]);
        }
    }
}

TEST(regression, void_pointer_test_1)
{
    __attribute__ ((aligned(128))) unsigned char a = 0;
    int actual = void_pointer(&a);
    EXPECT_EQ(2, actual);
}

TEST(regression, bool_array_head_test_1)
{
    _Bool b[10] = {false, false, false, false, false, false, false, false, false, false};
    _Bool actual = bool_array_head(b);
    EXPECT_EQ(false, actual);
    _Bool expected_b[10] = {false, false, false, false, false, false, false, false, false, false};
    for (int it_284_0 = 0; it_284_0 < 10; it_284_0 ++) {
        EXPECT_EQ(expected_b[it_284_0], b[it_284_0]);
    }
}

TEST(regression, structWithConstPointerReturn_test_1)
{
    const struct SupportedStruct4 actual = structWithConstPointerReturn(0);
    struct SupportedStruct4 expected = {
        .c = NULL};
}

TEST(regression, structWithConstPointerReturn_test_2)
{
    const struct SupportedStruct4 actual = structWithConstPointerReturn(1);
    struct SupportedStruct4 expected = {
        .c = NULL};
}

TEST(regression, structWithUnion_test_1)
{
    struct UnsupportedStruct3 actual = structWithUnion(-1);
    struct UnsupportedStruct3 expected = {
        .u = from_bytes<UnsupportedStruct3::U>({-1, -1, -1, -1})};
}

TEST(regression, structWithUnion_test_2)
{
    struct UnsupportedStruct3 actual = structWithUnion(0);
    struct UnsupportedStruct3 expected = {
        .u = from_bytes<UnsupportedStruct3::U>({50, -85, -85, -85})};
}

TEST(regression, structWithConstPointerReturnPointer_test_1)
{
    EXPECT_TRUE(structWithConstPointerReturnPointer(0) == NULL);
}

TEST(regression, structWithConstPointerReturnPointer_test_2)
{
    const struct SupportedStruct4 actual = *structWithConstPointerReturnPointer(2);
    struct SupportedStruct4 expected = {
        .c = NULL};
}

TEST(regression, structWithConstPointerParam_test_1)
{
    int actual = structWithConstPointerParam({
        .c = NULL});
    EXPECT_EQ(0, actual);
}

TEST(regression, structWithConstPointerParam_test_2)
{
    int actual = structWithConstPointerParam({
        .c = (char*) 0xff});
    EXPECT_EQ(2, actual);
}

TEST(regression, structWithConstFields_test_1)
{
    int actual = structWithConstFields({
        .b = 0,
        .a = 0,
        .c = 'c'});
    EXPECT_EQ(1, actual);
}

TEST(regression, structWithConstFields_test_2)
{
    int actual = structWithConstFields({
        .b = 0,
        .a = -1,
        .c = 'c'});
    EXPECT_EQ(2, actual);
}

#pragma endregion
#pragma region error
TEST(error, some_func_test_4)
{
    some_func('a', 128);
}

#pragma endregion
}
