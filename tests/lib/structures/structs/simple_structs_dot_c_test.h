/*
 * This file is automatically generated by UnitTestBot. For further information seehttps://unittestbot.org
 */

namespace UTBot {
#define typeid typeid_
#define throw throw_
#define true true_
#define thread_local thread_local_
#define template template_
#define static_cast static_cast_
#define requires requires_
#define public public_
#define protected protected_
#define reflexpr reflexpr_
#define operator operator_
#define noexcept noexcept_
#define new new_
#define namespace namespace_
#define mutable mutable_
#define try try_
#define private private_
#define friend friend_
#define false false_
#define virtual virtual_
#define nullptr nullptr_
#define export export_
#define this this_
#define explicit explicit_
#define typename typename_
#define delete delete_
#define decltype decltype_
#define co_yield co_yield_
#define co_return co_return_
#define co_await co_await_
#define const_cast const_cast_
#define constinit constinit_
#define consteval consteval_
#define class class_
#define synchronized synchronized_
#define char32_t char32_t_
#define constexpr constexpr_
#define char8_t char8_t_
#define catch catch_
#define using using_
#define char16_t char16_t_
#define atomic_noexcept atomic_noexcept_
#define concept concept_
#define atomic_commit atomic_commit_
#define static_assert static_assert_
#define atomic_cancel atomic_cancel_
#define dynamic_cast dynamic_cast_
#define asm asm_
#define reinterpret_cast reinterpret_cast_
#define alignof alignof_
#define alignas alignas_
#define _Alignas(x)
#define _Atomic(x) x
#define _Bool bool
#define _Noreturn
#define _Thread_local thread_local

struct __va_list_tag;
struct MyStruct {
    short x;
    const int a;
};

struct OneMoreStruct {
    int a;
    unsigned short c;
    long long b;
};

struct StructWithChars {
    char a;
    signed char c;
    unsigned char u;
    int b;
};

struct MainStruct {
    struct InnerStruct {
        struct InInnerStruct {
            unsigned int u;
            long long l;
        };
        char c;
        struct InInnerStruct ininner;
        short s;
    } inner;
    int x;
    long long y;
};

struct StructWithUnion {
    union InnerUnion {
        char c;
        int x;
    } un;
    struct InnerStructWithUnion {
        union Inner2Union {
            char c;
            int x;
        } un2;
    } is;
    int x;
};

struct A {
    union B {
        struct C {
            union D {
                char c;
                int x;
                double y;
            } arr;
        } t;
    } a;
};

struct StructWithUnionInUnion {
    union Union1 {
        int x;
        union Union2 {
            double y;
            char c;
        } t;
        char c;
    } un;
};

struct StructWithStructInUnion {
    union DeepUnion {
        int x;
        struct DeepStruct {
            char c;
            double d;
        } ds;
        long long *ptr;
    } un;
};


extern "C" int get_sign_struct_lib_structures_structs_simple_structs_c(struct MyStruct st);
static int get_sign_struct(struct MyStruct st) {
return get_sign_struct_lib_structures_structs_simple_structs_c(st);
}
extern "C" int calculate_something_lib_structures_structs_simple_structs_c(struct OneMoreStruct str);
static int calculate_something(struct OneMoreStruct str) {
return calculate_something_lib_structures_structs_simple_structs_c(str);
}
extern "C" char get_symbol_by_struct_lib_structures_structs_simple_structs_c(const struct StructWithChars st);
static char get_symbol_by_struct(const struct StructWithChars st) {
return get_symbol_by_struct_lib_structures_structs_simple_structs_c(st);
}
extern "C" signed char operate_with_inner_structs_lib_structures_structs_simple_structs_c(struct MainStruct st);
static signed char operate_with_inner_structs(struct MainStruct st) {
return operate_with_inner_structs_lib_structures_structs_simple_structs_c(st);
}
extern "C" struct MainStruct struct_as_return_type_lib_structures_structs_simple_structs_c(int a);
static struct MainStruct struct_as_return_type(int a) {
return struct_as_return_type_lib_structures_structs_simple_structs_c(a);
}
extern "C" struct StructWithUnion struct_with_union_as_return_type_lib_structures_structs_simple_structs_c(int t);
static struct StructWithUnion struct_with_union_as_return_type(int t) {
return struct_with_union_as_return_type_lib_structures_structs_simple_structs_c(t);
}
extern "C" struct A complex_struct_with_union_as_return_type_lib_structures_structs_simple_structs_c(int t);
static struct A complex_struct_with_union_as_return_type(int t) {
return complex_struct_with_union_as_return_type_lib_structures_structs_simple_structs_c(t);
}
extern "C" struct StructWithUnionInUnion struct_with_union_in_union_as_return_type_lib_structures_structs_simple_structs_c(int a, int b);
static struct StructWithUnionInUnion struct_with_union_in_union_as_return_type(int a, int b) {
return struct_with_union_in_union_as_return_type_lib_structures_structs_simple_structs_c(a, b);
}
extern "C" struct StructWithStructInUnion struct_with_struct_in_union_as_return_type_lib_structures_structs_simple_structs_c(int a, int b);
static struct StructWithStructInUnion struct_with_struct_in_union_as_return_type(int a, int b) {
return struct_with_struct_in_union_as_return_type_lib_structures_structs_simple_structs_c(a, b);
}

#ifdef wchar_t
#undef wchar_t
#endif

}
#undef typeid
#undef throw
#undef true
#undef thread_local
#undef template
#undef static_cast
#undef requires
#undef public
#undef protected
#undef reflexpr
#undef operator
#undef noexcept
#undef new
#undef namespace
#undef mutable
#undef try
#undef private
#undef friend
#undef false
#undef virtual
#undef nullptr
#undef export
#undef this
#undef explicit
#undef typename
#undef delete
#undef decltype
#undef co_yield
#undef co_return
#undef co_await
#undef const_cast
#undef constinit
#undef consteval
#undef class
#undef synchronized
#undef char32_t
#undef constexpr
#undef char8_t
#undef catch
#undef using
#undef char16_t
#undef atomic_noexcept
#undef concept
#undef atomic_commit
#undef static_assert
#undef atomic_cancel
#undef dynamic_cast
#undef asm
#undef reinterpret_cast
#undef alignof
#undef alignas
#include <cstring>

#include <unistd.h>


void utbot_redirect_stdin(const char* buf, int &res) {
    int fds[2];
    if (pipe(fds) == -1) {
        res = -1;
        return;
    }
    close(STDIN_FILENO);
    dup2(fds[0], STDIN_FILENO);
    write(fds[1], buf, 64);
    close(fds[1]);
}

template<typename T, size_t N>
T from_bytes(const char (&bytes)[N]) {
    T result;
    std::memcpy(&result, bytes, sizeof(result));
    return result;
}
