/*
 * This file is automatically generated by UnitTestBot. For further information see https://github.com/UnitTestBot/UTBotCpp
 * Copyright (c) Huawei Technologies Co., Ltd. 2012-2021. All rights reserved.
 */

namespace UTBot {
#define typeid typeid_
#define throw throw_
#define true true_
#define thread_local thread_local_
#define template template_
#define static_cast static_cast_
#define requires requires_
#define public public_
#define protected protected_
#define reflexpr reflexpr_
#define operator operator_
#define noexcept noexcept_
#define new new_
#define namespace namespace_
#define mutable mutable_
#define try try_
#define private private_
#define friend friend_
#define false false_
#define virtual virtual_
#define nullptr nullptr_
#define export export_
#define this this_
#define explicit explicit_
#define typename typename_
#define delete delete_
#define decltype decltype_
#define co_yield co_yield_
#define co_return co_return_
#define co_await co_await_
#define const_cast const_cast_
#define constinit constinit_
#define consteval consteval_
#define class class_
#define synchronized synchronized_
#define char32_t char32_t_
#define constexpr constexpr_
#define char8_t char8_t_
#define catch catch_
#define using using_
#define char16_t char16_t_
#define atomic_noexcept atomic_noexcept_
#define concept concept_
#define atomic_commit atomic_commit_
#define static_assert static_assert_
#define atomic_cancel atomic_cancel_
#define dynamic_cast dynamic_cast_
#define asm asm_
#define reinterpret_cast reinterpret_cast_
#define alignof alignof_
#define alignas alignas_
#define _Alignas(x)
#define _Atomic(x) x
#define _Bool bool
#define _Noreturn
#define _Thread_local thread_local

union IntBytesUnion {
    char bytes[4];
    int number;
};

union ShortBytesUnion {
    char bytes[2];
    short number;
};

union SuperFloat {
    float f;
    int i;
};

union Vector2D {
    int m[2];
    struct {
        int x;
        int y;
    };
};

union Heterogeneous {
    int a;
    long long b;
    unsigned short c;
};

union MainUnion {
    union InnerUnion {
        union InInnerUnion {
            unsigned int u;
            long long l;
        };
        char c;
        union InInnerUnion ininner;
        short s;
    } inner;
    int x;
    long long y;
};

typedef enum  {
    CHAR_TAG,
    INT_TAG
} VariantTag;

struct Variant {
    VariantTag tag;
    union VariantData {
        char c;
        int i;
    } data;
};

union UnionWithPointer {
    int *a;
    long long b;
};

typedef long ptrdiff_t;

typedef unsigned long size_t;

typedef struct {
    long long __max_align_ll __attribute__((aligned(__alignof(long long))));
    long double __max_align_ld __attribute__((aligned(__alignof(long double))));
} max_align_t;


extern "C" int get_sign_union_lib_structures_simple_unions_c(union IntBytesUnion st);
static int get_sign_union(union IntBytesUnion st) {
return get_sign_union_lib_structures_simple_unions_c(st);
}
extern "C" int extract_bit_lib_structures_simple_unions_c(union ShortBytesUnion x);
static int extract_bit(union ShortBytesUnion x) {
return extract_bit_lib_structures_simple_unions_c(x);
}
extern "C" int calculate_something_union_lib_structures_simple_unions_c(union Heterogeneous str);
static int calculate_something_union(union Heterogeneous str) {
return calculate_something_union_lib_structures_simple_unions_c(str);
}
extern "C" int RawMantissa_lib_structures_simple_unions_c(union SuperFloat f);
static int RawMantissa(union SuperFloat f) {
return RawMantissa_lib_structures_simple_unions_c(f);
}
extern "C" int get_coordinate_lib_structures_simple_unions_c(union Vector2D vect, int i);
static int get_coordinate(union Vector2D vect, int i) {
return get_coordinate_lib_structures_simple_unions_c(vect, i);
}
extern "C" signed char operate_with_inner_unions_lib_structures_simple_unions_c(union MainUnion st);
static signed char operate_with_inner_unions(union MainUnion st) {
return operate_with_inner_unions_lib_structures_simple_unions_c(st);
}
extern "C" union MainUnion union_as_return_type_lib_structures_simple_unions_c(int a);
static union MainUnion union_as_return_type(int a) {
return union_as_return_type_lib_structures_simple_unions_c(a);
}
extern "C" int sumOfUnionArray_lib_structures_simple_unions_c(union IntBytesUnion u[5]);
static int sumOfUnionArray(union IntBytesUnion u[5]) {
return sumOfUnionArray_lib_structures_simple_unions_c(u);
}
extern "C" long long operateWithUnionWithPointer_lib_structures_simple_unions_c(union UnionWithPointer un);
static long long operateWithUnionWithPointer(union UnionWithPointer un) {
return operateWithUnionWithPointer_lib_structures_simple_unions_c(un);
}

}
#undef typeid
#undef throw
#undef true
#undef thread_local
#undef template
#undef static_cast
#undef requires
#undef public
#undef protected
#undef reflexpr
#undef operator
#undef noexcept
#undef new
#undef namespace
#undef mutable
#undef try
#undef private
#undef friend
#undef false
#undef virtual
#undef nullptr
#undef export
#undef this
#undef explicit
#undef typename
#undef delete
#undef decltype
#undef co_yield
#undef co_return
#undef co_await
#undef const_cast
#undef constinit
#undef consteval
#undef class
#undef synchronized
#undef char32_t
#undef constexpr
#undef char8_t
#undef catch
#undef using
#undef char16_t
#undef atomic_noexcept
#undef concept
#undef atomic_commit
#undef static_assert
#undef atomic_cancel
#undef dynamic_cast
#undef asm
#undef reinterpret_cast
#undef alignof
#undef alignas
#include <cstring>

#include <unistd.h>


void utbot_redirect_stdin(const char* buf, int &res) {
    int fds[2];
    if (pipe(fds) == -1) {
        res = -1;
        return;
    }
    close(STDIN_FILENO);
    dup2(fds[0], STDIN_FILENO);
    write(fds[1], buf, 64);
    close(fds[1]);
}

template<typename T, size_t N>
T from_bytes(const char (&bytes)[N]) {
    T result;
    std::memcpy(&result, bytes, sizeof(result));
    return result;
}
