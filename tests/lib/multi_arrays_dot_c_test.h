/*
 * This file is automatically generated by UnitTestBot. For further information seehttps://unittestbot.org
 */

namespace UTBot {
#define typeid typeid_
#define throw throw_
#define true true_
#define thread_local thread_local_
#define template template_
#define static_cast static_cast_
#define requires requires_
#define public public_
#define protected protected_
#define reflexpr reflexpr_
#define operator operator_
#define noexcept noexcept_
#define new new_
#define namespace namespace_
#define mutable mutable_
#define try try_
#define private private_
#define friend friend_
#define false false_
#define virtual virtual_
#define nullptr nullptr_
#define export export_
#define this this_
#define explicit explicit_
#define typename typename_
#define delete delete_
#define decltype decltype_
#define co_yield co_yield_
#define co_return co_return_
#define co_await co_await_
#define const_cast const_cast_
#define constinit constinit_
#define consteval consteval_
#define class class_
#define synchronized synchronized_
#define char32_t char32_t_
#define constexpr constexpr_
#define char8_t char8_t_
#define catch catch_
#define using using_
#define char16_t char16_t_
#define atomic_noexcept atomic_noexcept_
#define concept concept_
#define atomic_commit atomic_commit_
#define static_assert static_assert_
#define atomic_cancel atomic_cancel_
#define dynamic_cast dynamic_cast_
#define asm asm_
#define reinterpret_cast reinterpret_cast_
#define alignof alignof_
#define alignas alignas_
#define _Alignas(x)
#define _Atomic(x) x
#define _Bool bool
#define _Noreturn
#define _Thread_local thread_local

struct __va_list_tag;
typedef unsigned long size_t;

struct __locale_struct {
    struct __locale_data *__locales[13];
    const unsigned short *__ctype_b;
    const int *__ctype_tolower;
    const int *__ctype_toupper;
    const char *__names[13];
};

typedef struct __locale_struct *__locale_t;

typedef __locale_t locale_t;

struct MyStructMult {
    int a[2][3][2];
};

struct IntArray {
    int ints[2][5];
};

struct PointStruct {
    int x;
    int y;
};


extern "C" int kek_lib_multi_arrays_c(int a[1][2]);
static int kek(int a[1][2]) {
return kek_lib_multi_arrays_c(a);
}
extern "C" int sumSign_lib_multi_arrays_c(int a[2][2]);
static int sumSign(int a[2][2]) {
return sumSign_lib_multi_arrays_c(a);
}
extern "C" int value_lib_multi_arrays_c(int a[2][3]);
static int value(int a[2][3]) {
return value_lib_multi_arrays_c(a);
}
extern "C" int value2_lib_multi_arrays_c(int (*a)[3]);
static int value2(int (*a)[3]) {
return value2_lib_multi_arrays_c(a);
}
extern "C" int some_method_lib_multi_arrays_c(int **pointer2d);
static int some_method(int **pointer2d) {
return some_method_lib_multi_arrays_c(pointer2d);
}
extern "C" int return_sign_sum_lib_multi_arrays_c(struct MyStructMult st);
static int return_sign_sum(struct MyStructMult st) {
return return_sign_sum_lib_multi_arrays_c(st);
}
extern "C" long long return_sign_sum_of_struct_array_lib_multi_arrays_c(struct PointStruct arr[2][2]);
static long long return_sign_sum_of_struct_array(struct PointStruct arr[2][2]) {
return return_sign_sum_of_struct_array_lib_multi_arrays_c(arr);
}
extern "C" int point_quart_lib_multi_arrays_c(struct PointStruct **point);
static int point_quart(struct PointStruct **point) {
return point_quart_lib_multi_arrays_c(point);
}
extern "C" struct IntArray return_struct_with_2d_array_lib_multi_arrays_c(int a);
static struct IntArray return_struct_with_2d_array(int a) {
return return_struct_with_2d_array_lib_multi_arrays_c(a);
}
extern "C" int (*matrix_a_lib_multi_arrays_c)[3][2];
int (&matrix_a)[3][2] = (*matrix_a_lib_multi_arrays_c);
extern "C" int (*matrix_b_lib_multi_arrays_c)[3][2];
int (&matrix_b)[3][2] = (*matrix_b_lib_multi_arrays_c);
extern "C" int (*matrix_c_lib_multi_arrays_c)[3][2];
int (&matrix_c)[3][2] = (*matrix_c_lib_multi_arrays_c);
extern "C" int sum_matrix_lib_multi_arrays_c();
static int sum_matrix() {
return sum_matrix_lib_multi_arrays_c();
}
extern "C" int (*argc_lib_multi_arrays_c);
int (&argc) = (*argc_lib_multi_arrays_c);
extern "C" char **(*argv_lib_multi_arrays_c);
char **(&argv) = (*argv_lib_multi_arrays_c);
extern "C" int count_dashes_lib_multi_arrays_c();
static int count_dashes() {
return count_dashes_lib_multi_arrays_c();
}

#ifdef wchar_t
#undef wchar_t
#endif

}
#undef typeid
#undef throw
#undef true
#undef thread_local
#undef template
#undef static_cast
#undef requires
#undef public
#undef protected
#undef reflexpr
#undef operator
#undef noexcept
#undef new
#undef namespace
#undef mutable
#undef try
#undef private
#undef friend
#undef false
#undef virtual
#undef nullptr
#undef export
#undef this
#undef explicit
#undef typename
#undef delete
#undef decltype
#undef co_yield
#undef co_return
#undef co_await
#undef const_cast
#undef constinit
#undef consteval
#undef class
#undef synchronized
#undef char32_t
#undef constexpr
#undef char8_t
#undef catch
#undef using
#undef char16_t
#undef atomic_noexcept
#undef concept
#undef atomic_commit
#undef static_assert
#undef atomic_cancel
#undef dynamic_cast
#undef asm
#undef reinterpret_cast
#undef alignof
#undef alignas
#include <cstring>

#include <unistd.h>


void utbot_redirect_stdin(const char* buf, int &res) {
    int fds[2];
    if (pipe(fds) == -1) {
        res = -1;
        return;
    }
    close(STDIN_FILENO);
    dup2(fds[0], STDIN_FILENO);
    write(fds[1], buf, 64);
    close(fds[1]);
}

template<typename T, size_t N>
T from_bytes(const char (&bytes)[N]) {
    T result;
    std::memcpy(&result, bytes, sizeof(result));
    return result;
}
